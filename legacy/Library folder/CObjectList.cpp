/****************************************************************************** CObjectList.cp   ******************************************************************************/#include "CObjectList.h"#define	kGrowAmount			5#define	kIllegalIndex		-1CObjectList::CObjectList(long initialItems){	fCount = 0;	fArray = (long **)NewHandle(0);	HLock( (Handle) fArray);}CObjectList::~CObjectList(){	DisposeHandle((Handle) fArray);	fArray = nil;	fCount = 0;}		void		CObjectList::Add(void * object){	long	slotsAvail = 					GetHandleSize((Handle) fArray) / sizeof(void *);		// Resize the handle if necessary 	if(fCount + 1 >= slotsAvail)	{		ResizeArray(slotsAvail + kGrowAmount);	}		// Get a pointer to the slot in the list	long * slotPtr = (long *)ObjectPtr(fCount + 1);		// Copy the object pointer into the slot	*slotPtr = (long)object;		// Up the list counter	fCount++;}void		CObjectList::Remove(void * object){	long index = FindIndex(object);		if(index != kIllegalIndex)	{		index++; // Convert from 0 based index to 1 based		fCount--;		if (index <= fCount) 		{								// Shift items up following the object.			// Wiping out the object pointer.			BlockMove(ObjectPtr(index+1), 								ObjectPtr(index),								(fCount - index + 1) * sizeof(void *) );		}			// resize the array handle if necessary		long	slots = GetHandleSize((Handle) fArray) / sizeof(void *);		if (slots > fCount + kGrowAmount)			ResizeArray(slots - kGrowAmount);	}}		void		CObjectList::ResizeArray(long slots){	HUnlock((Handle)fArray);	SetHandleSize((Handle) fArray, slots * sizeof(void *));	HLock((Handle)fArray);	if (slots < fCount)		fCount = slots;}/*void	CObjectList::AddAtNthPosition(void * object, long index){	if( ! (index < 1 || index > fCount)	{		Add(object);	// add placeholder				BlockMove(ObjectPtr(index), 							ObjectPtr(index + 1),							(fCount - index - 1) * sizeof(void *) );				InsertAtNthPosition(object, index);	}}  mf79 lšschen */		void	CObjectList::InsertAtNthPosition(void * object, long index){	long	*		slotPtr;		if( ! (index < 1 || index > fCount) )	{		slotPtr = (long *)ObjectPtr(index);		*slotPtr = (long)object;	}		}void	CObjectList::MoveToAnotherPosition(long source, long destination){	void *	tempObject;		if( ! (source < 1 || source > fCount) ||		 	(destination < 1 || destination > fCount) )		if(source < destination)		{			tempObject = GetNthObject(source);					BlockMove(ObjectPtr(source + 1),					ObjectPtr(source),					(destination - source) * sizeof(void *) );					InsertAtNthPosition(tempObject, destination);		}		else if(source > destination)		{			tempObject = GetNthObject(source);							BlockMove(ObjectPtr(destination),					ObjectPtr(destination + 1),					(source - destination) * sizeof(void *) );					InsertAtNthPosition(tempObject, destination);		}}long		CObjectList::FindIndex(void * object){	for (long i = 0; i < fCount; i++) 		if ((long)object == (*fArray)[i] )			return(i);	// Bail. Couldn't find requested object	return(kIllegalIndex);}void	CObjectList::FreeAll(){	for (long i = 0; i < fCount; i++)	{		delete((void *)(*fArray)[i]);		(*fArray)[i] = nil;	}	fCount = 0;	ResizeArray(0);}