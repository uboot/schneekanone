/****************************************************************************** CSprite.cp   ******************************************************************************/#include "Assert.h"#include "CSprite.h"#include "ErrorHandler.h"#define	kSpriteTemplate	'SpTm'class CCelList	: public CObjectList	{public:	CCelList();	~CCelList();		void	IncrementRefCount() { fRefCount++; }	void	DecrementRefCount() { fRefCount--; }	short	GetRefCount() { return fRefCount; }	protected:	short	fRefCount;};typedef struct {	OSType		id;	short		horzPosition;	short		vertPosition;	long		moveDelay;	long		moveDelayMult;	long		celDelay;	long		celDelayMult;	short		visible;	short		celIndex;	short 		celCount;	short		cicnIDs[1];} SpriteTemplate, *SpriteTempPtr, **SpriteTempHand;CSprite::CSprite(SpriteID spriteID){	SpriteX();	fDogTag = spriteID;}CSprite::CSprite(short templateID){	OSErr			err;	SpriteTempHand templateH;	short			index;		SpriteX();		fCels = new(CCelList);	if(fCels == nil)		PostFatalError(memFullErr);		// Get the sprite load template resource	templateH = (SpriteTempHand)GetResource(kSpriteTemplate, templateID);	if(templateH == nil)	{		PostFatalError(ResError());		return;	}		// Create each cel and add it to the cel list	err = noErr;	HLock((Handle) templateH);	for(short i = 0; i < (*templateH)->celCount; i++)	{		CSpriteCel * cel;				cel = new CSpriteCel ((*templateH)->cicnIDs[i]);		fCels->Add(cel);	}		// Fill in the rest of the fields	fDogTag = (*templateH)->id;	fVisible = (*templateH)->visible != 0;	index = (*templateH)->celIndex;	if(index > (*templateH)->celCount)		index = 1;			SetStartingPosition((*templateH)->horzPosition, 						(*templateH)->vertPosition);		// Mark the cel list as used	fCels->IncrementRefCount();		// Show correct cel	SetCurrentCel(index);		// Fire up them timers	SetAutoMoveTime((*templateH)->moveDelay, (*templateH)->moveDelayMult);	SetCelCycleTime((*templateH)->celDelay, (*templateH)->celDelayMult);		HUnlock((Handle) templateH);	ReleaseResource((Handle) templateH);}CSprite::CSprite(CSprite & source ){	SpriteX();		fDogTag = source.fDogTag;	fCurrBnds = source.fCurrBnds;	fPrevBnds = source.fPrevBnds;	fEraseBnds = source.fEraseBnds;	fCurrWidth = source.fCurrWidth;	fCurrHeight = source.fCurrHeight;	fMoveExtent = source.fMoveExtent;		fEraseMe = source.fEraseMe;	fDrawMe = source.fDrawMe;	fVisible = source.fDrawMe;		fMoveHoriz = source.fMoveHoriz;	fMoveVert = source.fMoveVert;	fCels = source.fCels;	if(fCels)		fCels->IncrementRefCount();	fCurrentCel = source.fCurrentCel;	fCelIndex = source.fCelIndex;	fMoveDelay = source.fMoveDelay;	fMoveDelayMult = source.fMoveDelayMult;	fCelDelay = source.fCelDelay;	fCelDelayMult = source.fCelDelayMult;}void * CSprite::Clone(){	return (new CSprite (*this));}void	CSprite::SpriteX(){	// Zero out the rects	SetRect(&fCurrBnds,0,0,0,0);	fPrevBnds = fMoveExtent = fEraseBnds = fCurrBnds;	fCurrWidth = 0;	fCurrHeight = 0;	fEraseMe = FALSE;	fDrawMe = TRUE;	fVisible = TRUE;	fMoveDelay = kNoMovement;	fMoveDelayMult = 1;	fAutoMoveIndex = 1;	fMoveHoriz = 0;	fMoveVert = 0;		fCelDelay = kNoMovement;	fMoveDelayMult = 1;	fCelChangeIndex = 1;		fCels = nil;	fCurrentCel = nil;	fCelIndex = 1;}CSprite::~CSprite(){	if(fCels && fCels->GetRefCount() <= 1)	{		for(long i = 1; i <= fCels->GetObjectCount(); i++)		{			CSpriteCel *	currCel;						currCel = (CSpriteCel *) fCels->GetNthObject(i);						delete(currCel);		}				fCels->FreeAll();				delete(fCels);	}	else		fCels->DecrementRefCount();		fCels = nil;   // mf79 gelšscht 1/3/96}void	CSprite::Offset(short dh, short dv){	if (dh || dv)	{		OffsetRect(&fCurrBnds, dh, dv);		fDrawMe = TRUE;		fEraseMe = TRUE;	}}void	CSprite::MoveTo(short h, short v){	if( h || v)	{		fCurrBnds.top = v;		fCurrBnds.left = h;		fCurrBnds.bottom = v + fCurrHeight;		fCurrBnds.right = h + fCurrWidth;				fDrawMe = TRUE;		fEraseMe = TRUE;	}}void	CSprite::SetStartingPosition(short h, short v){	fCurrBnds.top = v;	fCurrBnds.left = h;	fCurrBnds.bottom = v + fCurrHeight;	fCurrBnds.right = h + fCurrWidth;	fEraseBnds = fCurrBnds;	fPrevBnds = fCurrBnds;		fDrawMe = TRUE;}void	CSprite::SetAutoMoveTime(long moveDelay, long moveDelayMult){	fMoveDelay = moveDelay;	fMoveDelayMult = moveDelayMult;}Boolean	CSprite::IsTimeToMove(){	Boolean	returnValue;		returnValue = fMoveDelay > kNoMovement ? fAutoMoveIndex <= fMoveDelayMult									 : false;		if (fMoveDelay > kNoMovement)		if (fAutoMoveIndex > 1)			fAutoMoveIndex--;		else			fAutoMoveIndex = fMoveDelay;				return returnValue;}Boolean	CSprite::IsTimeToChangeCels(){	Boolean	returnValue;		returnValue = fCelDelay > kNoMovement ? fCelChangeIndex <= fCelDelayMult									 : false;		if (fCelDelay > kNoMovement)		if (fCelChangeIndex > 1)			fCelChangeIndex--;		else			fCelChangeIndex = fCelDelay;				return returnValue;}void	CSprite::SetAutoMove(short dh, short dv){	fMoveHoriz = dh;	fMoveVert = dv;}void	CSprite::Move(){	if (fMoveHoriz || fMoveVert)	{		OffsetRect(&fCurrBnds, fMoveHoriz, fMoveVert);		fDrawMe = TRUE;		fEraseMe = TRUE;	}}											 void	CSprite::SetCurrentCel(short index){	fCurrentCel = (CSpriteCel *) fCels->GetNthObject(index);	fCelIndex = index;	if(fCurrentCel)	{		Rect	 	celBnds;		Rect	 	lastBnds = fCurrBnds;		fCurrentCel->GetCelBnds(&fCurrBnds); 				OffsetRect(&fCurrBnds, 					lastBnds.left - fCurrBnds.left,					lastBnds.top - fCurrBnds.top);				fCurrWidth = fCurrBnds.right - fCurrBnds.left;		fCurrHeight = fCurrBnds.bottom - fCurrBnds.top;		// As the new cel could be smaller 		// than the current one we need to force		// an erase as well as a draw		if(fVisible)		{			fEraseMe = TRUE;			fDrawMe = TRUE;		}	}}void	CSprite::SetCelCycleTime(long cycleDelay, long cycleDelayMult){	fCelDelay = cycleDelay;	fCelDelayMult = cycleDelayMult;}void	CSprite::ChangeCel(){		fCelIndex++;	if(fCelIndex > fCels->GetObjectCount())		fCelIndex = 1;			SetCurrentCel(fCelIndex);}void	CSprite::BlitFrame(GWorldPtr destBuffer){	if(fCurrentCel)		fCurrentCel->BlitToBuffer(destBuffer,&fCurrBnds); }void	CSprite::Collide(CSprite * source){	// Default method does nothing	}void	CSprite::MarkAsOnscreen(){ 	fEraseMe = FALSE; 	fDrawMe = FALSE;	fEraseBnds = fCurrBnds;	fPrevBnds = fCurrBnds;}/*---------------------------------------------------------------------------	Cel list member functions---------------------------------------------------------------------------*/CCelList::CCelList(){	fRefCount = 0;}CCelList::~CCelList(){	ASSERT(fRefCount <= 1);}