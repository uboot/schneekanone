/****************************************************************************** CSprite.h   ******************************************************************************/#pragma once#include <QDOffscreen.h>#include "CObjectList.h"#include "CSpriteCel.h"typedef	OSType	SpriteID;const	kNoMovement = -1;class CSpriteCel;class CCelList;class CSprite {public:			// Constructors			CSprite() { SpriteX(); }			CSprite(SpriteID spriteID);			CSprite(short templateID );			CSprite(CSprite & source );			// Destructors	virtual	~CSprite();			// copying	virtual	void * Clone();				// Sprite movement			void	MoveTo(short h, short v);			void	Offset(short dh, short dv);						void	SetAutoMoveTime(long moveDelay, long moveDelayMult);				virtual	void	SetStartingPosition(short h, short v);	virtual	void	SetAutoMove(short dh, short dv);						short 	GetAutoMoveHorz() 						{ return fMoveHoriz; }			short 	GetAutoMoveVert()						{ return fMoveVert; }			void	GetPosition(Rect * currPos)						{ *currPos = fCurrBnds; }			void	GetPrevPosition(Rect * prevPos)						{ *prevPos = fPrevBnds; }			Boolean	IsTimeToMove();	virtual	void	Move();			// Sprite allowed movement bounds			void	SetSpriteExtent(const Rect * extent)						{ fMoveExtent = *extent; }			void	GetSpriteExtent(Rect * extent)						{ *extent = fMoveExtent; } 			// Cel animation	virtual	void	SetCurrentCel(short index);			void	SetCelCycleTime(long cycleDelay, long cycleDelayMult);			CSpriteCel *GetCurrentCel()						{ return fCurrentCel; }									short	GetCurrentCelIndex()						{ return fCelIndex; }			Boolean	IsTimeToChangeCels();					void	ChangeCel();					// Core sprite routines		virtual	void	BlitFrame(GWorldPtr destBuffer);	virtual	void	Collide(CSprite * source);				// Sprite visibility			Boolean	IsVisible() { return fVisible; }			void	Hide()					{ 	fVisible = FALSE; 						fDrawMe = TRUE;						fEraseMe = TRUE;					}								void	Show()					{ 	fVisible = TRUE; 						fDrawMe = TRUE;						fEraseMe = FALSE;					}								void	Refresh() {	fDrawMe = TRUE; fEraseMe = TRUE; }			// Total bounds			void	GetEraseRect(Rect * eraseBnds)						{ *eraseBnds = fEraseBnds; }				// Sprite status			Boolean	ShouldDraw() 						{ return fDrawMe && fVisible; }			Boolean	ShouldErase() 						{ return fEraseMe; }			Boolean	NeedCopiedOnscreen() 						{ return fDrawMe || fEraseMe; }			void	MarkAsOnscreen();						// Sprite tagging			void		SetDogTag(SpriteID id) 							{ fDogTag = id; }			SpriteID	GetDogTag() 							{ return fDogTag; }			short	GetHeight() { return fCurrHeight; }			short	GetWidth() { return fCurrWidth; }			protected:	Rect				fCurrBnds;	Rect				fPrevBnds;	Rect				fEraseBnds;		short				fCurrWidth;	short				fCurrHeight;		Boolean				fEraseMe;	Boolean				fDrawMe;	Boolean				fVisible;		CCelList *			fCels;	CSpriteCel *		fCurrentCel;	short				fCelIndex;	SpriteID			fDogTag;		long				fMoveDelay;	long				fMoveDelayMult;	long				fCelDelay;	long				fCelDelayMult;		short				fAutoMoveIndex;	short				fCelChangeIndex;		short				fMoveHoriz;	short				fMoveVert;		Rect				fMoveExtent;private:						void	SpriteX();				};