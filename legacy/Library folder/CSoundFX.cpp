/****************************************************************************** CSoundFX.cp   ******************************************************************************/#include "CSoundFX.h"#include "ErrorHandler.h"CSoundFX::CSoundFX(){	OSErr err = noErr;		fSoundStopped = FALSE;		for(short i = 0; i < kMaxChannels; i++) 	{		fChannels[i].channelUsed = nil;		fChannels[i].priority = kNothingPlaying;		fChannels[i].currSnd = nil;		// Create all the channels upon creation		err = SndNewChannel(&fChannels[i].channelUsed, 							sampledSynth, 							initMono + initNoInterp, 							NULL);		if(err != noErr) 		{			PostFatalError(err);			break;		}	}		if(err == noErr)		fSoundStopped = TRUE;	}CSoundFX::~CSoundFX(){		Silence();		for(short i = 0; i < kMaxChannels; i++) 	{		OSErr err;				err = SndDisposeChannel (fChannels[i].channelUsed, true);				fChannels[i].channelUsed = nil;		fChannels[i].priority = kNothingPlaying;		fChannels[i].currSnd = nil;	}}void CSoundFX::PlaySnd(short sndID, SoundPriority priority){	Handle	sndH;	AsynchChannel *	channel = nil;	SCStatus		soundChannelStatus;		if(!fSoundStopped)		return;			sndH = (Handle) GetResource('snd ', sndID);	if(sndH == nil)	{		PostFatalError(ResError());		return;	}		HLock((Handle) sndH);		// Find a channel to play from, first looking for one that isn't aready busy	channel = nil;	for(short i = 0; i < kMaxChannels; i++)	{		SndChannelStatus(fChannels[i].channelUsed, sizeof(SCStatus),							&soundChannelStatus);				fChannels[i].stillPlaying = soundChannelStatus.scChannelBusy;				if(fChannels[i].stillPlaying == FALSE)		{			channel = &fChannels[i];			break;		}	}		// If all the channels were busy try to find one with lower priority snd	if(channel == nil)	{		for(short i = 0; i < kMaxChannels; i++)		{			if(fChannels[i].priority <  priority)			{				channel = &fChannels[i];				break;			}		}	}		// If a channel was found silence it if necessary and then start playback	if(channel)	{		OSErr		err = noErr;		SndCommand	cmd;		// Shutdown a channel that is still playing		if(channel->stillPlaying)		{						cmd.cmd = quietCmd;			cmd.param1 = 0;			cmd.param2 = 0;			err = SndDoImmediate(channel->channelUsed, &cmd);			cmd.cmd = flushCmd;			err = SndDoImmediate(channel->channelUsed, &cmd);		}				if(err == noErr)		{			// Show that the sound is playing before calling SndPlay			// This avoids a potential race condition that would close			// off the channel forever			channel->stillPlaying = TRUE;			channel->priority = priority;			channel->currSnd = sndH;						err = SndPlay (channel->channelUsed, (SndListResource **)sndH, TRUE);			if (err != noErr) 			{				HUnlock((Handle)channel->currSnd);				channel->currSnd = nil;				PostFatalError(err);			}		}		else			PostFatalError(err);			}}void CSoundFX::PlaySndAlarm(short sndID){	Boolean oldStop;		oldStop = fSoundStopped;		fSoundStopped = TRUE;		PlaySnd(sndID, kAlarmPriority);	fSoundStopped = oldStop;}void CSoundFX::Silence(){	SCStatus		soundChannelStatus;	for(short i = 0; i < kMaxChannels; i++)	{		SndChannelStatus(fChannels[i].channelUsed, sizeof(SCStatus),							&soundChannelStatus);				fChannels[i].stillPlaying = soundChannelStatus.scChannelBusy;				if(fChannels[i].stillPlaying)		{			SndCommand	cmd;			OSErr		err;						cmd.cmd = quietCmd;			cmd.param1 = 0;			cmd.param2 = 0;			err = SndDoImmediate(fChannels[i].channelUsed, &cmd);			cmd.cmd = flushCmd;			err = SndDoImmediate(fChannels[i].channelUsed, &cmd);						// Mark the channel as empty			fChannels[i].stillPlaying = FALSE;			fChannels[i].priority = kNothingPlaying;			HUnlock((Handle)fChannels[i].currSnd);		}	}}void CSoundFX::SoundFXTask(){	SCStatus		soundChannelStatus;		for(short i = 0; i < kMaxChannels; i++)	{		SndChannelStatus(fChannels[i].channelUsed, sizeof(SCStatus),							&soundChannelStatus);				fChannels[i].stillPlaying = soundChannelStatus.scChannelBusy;		if(fChannels[i].stillPlaying == FALSE)		{						// Mark the channel as empty			fChannels[i].stillPlaying = FALSE;			fChannels[i].priority = kNothingPlaying;			if(fChannels[i].currSnd)				HUnlock((Handle)fChannels[i].currSnd);			fChannels[i].currSnd = nil;		}	}}