/******************************************************************************PrivateUtilities.c   ******************************************************************************/#include "PrivateUtilities.h"/****************************************************************************** KeyIsDown		Determine whether or not the specified key is being pressed. Keys		are specified by hardware-specific key code (NOT the character).		******************************************************************************/Boolean		KeyIsDown(	short			theKeyCode){	KeyMap			theKeys;	GetKeys(theKeys);					// Get state of each key		// Ordering of bits in a KeyMap is truly bizarre. A KeyMap is a		// 16-byte (128 bits) array where each bit specifies the start		// of a key (0 = up, 1 = down). We isolate the bit for the		// specified key code by first determining the byte position in		// the KeyMap and then the bit position within that byte.		// Key codes 0-7 are in the first byte (offset 0 from the		// start), codes 8-15 are in the second, etc. The BitTst() trap		// counts bits starting from the high-order bit of the byte.		// For example, for key code 58 (the option key), we look at		// the 8th byte (7 offset from the first byte) and the 5th bit		// within that byte.	return(BitTst(((char*) &theKeys) + theKeyCode / 8,					(long) 7 - (theKeyCode % 8) ) );}/****************************************************************************** IsLogicalCollision		******************************************************************************/Boolean IsLogicalCollision ( PixMapPtr spriteMask1Ptr,							  PixMapPtr spriteMask2Ptr,							  const Rect * sprite1Bnds, 							  const Rect * sprite2Bnds,							  const Rect * sectBnds)							  {		short		xDiff, yDiff;	char 		*mask1Ptr, *mask2Ptr;	Rect 		*bnds1, *bnds2;	short		mask1RowBytes, mask2RowBytes;	short		xCnt, yCnt;	short		offset1, offset2;		xDiff = sprite1Bnds->left - sprite2Bnds->left;		if(xDiff > 0)	{		bnds1 = (Rect *)sprite2Bnds;		bnds2 = (Rect *)sprite1Bnds;		mask1Ptr = spriteMask2Ptr->baseAddr + xDiff;		mask2Ptr = spriteMask1Ptr->baseAddr;		mask1RowBytes = spriteMask2Ptr->rowBytes & 0x7FFF;		mask2RowBytes = spriteMask1Ptr->rowBytes & 0x7FFF;		offset1 = 0;		offset2 = xDiff;	}	else	{		bnds1 = (Rect *)sprite1Bnds;		bnds2 = (Rect *)sprite2Bnds;		mask1Ptr = spriteMask1Ptr->baseAddr - xDiff;		mask2Ptr = spriteMask2Ptr->baseAddr;		mask1RowBytes = spriteMask1Ptr->rowBytes & 0x7FFF;		mask2RowBytes = spriteMask2Ptr->rowBytes & 0x7FFF;		offset1 = -xDiff;		offset2 = 0;	}		yDiff = bnds1->top - bnds2->top;		if(yDiff < 0)		mask1Ptr += mask1RowBytes * (-yDiff);	else		mask2Ptr += mask2RowBytes * yDiff;			for(yCnt = sectBnds->top; yCnt < sectBnds->bottom; yCnt++)	{		for(xCnt = sectBnds->left; xCnt < sectBnds->right; xCnt++)		{			if(*mask1Ptr && *mask2Ptr)				return true;						mask1Ptr++;			mask2Ptr++;		}				mask1Ptr += mask1RowBytes - (sectBnds->right - sectBnds->left);		mask2Ptr += mask2RowBytes -	(sectBnds->right - sectBnds->left);	}		return false;}/***********************************************************************MovePenTo 	 	***********************************************************************/  void			MovePenTo(short h, short v){	HidePen();	LineTo(h, v);	ShowPen();}	