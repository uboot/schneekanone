/****************************************************************************** CommonUtilities.c   ******************************************************************************/#include "CommonUtilities.h"#include "Global.h"#include "StringUtilities.h"#include "Assert.h"#include <Traps.h>#define kErrorStringResType 'Estr'#define kAnonymousError     1000#define kErrorALRT_ID       2000/************************************************************ PostErrorAlert    Display an alert that attempts to explain the error to the user. The paramater "error" is used to get a pascal string explaining the error code. This is accomplished by using "error" as a resource id for the resource type 'Estr'.  If a 'Estr' does not exist for the given error a default string will be used.The error number is also displayed in the alert************************************************************/             void    PostErrorAlert(short error){    Str255  errStr, numStr;    StringHandle    strH;    // try and find an 'Estr' resource that matches         // "error."    strH = (StringHandle)         GetResource(kErrorStringResType, error);        // see if a 'Estr' existed for "error."    if(!strH)        strH = GetString( kAnonymousError);         // no 'Estr', get the default string        // Yeaaa, we got a string Handle, copy it to errStr    if(strH)        CopyPString( *strH, errStr);    // convert the error into a string    NumToString(error, numStr);        // tell the dialog manager to use our     // two strings for ^0 and ^1    ParamText(errStr, numStr, NULL, NULL);    // Position the alert according to the HIG    HIG_PositionDialog( 'ALRT', kErrorALRT_ID);        // remove any stray cursors    InitCursor();        //display the alert    StopAlert( kErrorALRT_ID, NULL);}/************************************************************ HIG_PositionDialog       Position Alerts and dialogs on the mac screen according     to the Human Interface Guidelines. Right now I interpert     that to mean the dialog should be placed in the upper     third of the main screen.        This functions can be used with ALRTs as well as DLOGs. ************************************************************/void    HIG_PositionDialog( ResType dialogType, short id){    Handle theTemplate; // Handle to resource template    Rect        *theRect;   // Bounding box of dialog    short       left;       // Left side of centered rect       short       top;        // Top side of centered rect                theTemplate = GetResource(dialogType, id);    theRect = (Rect*) *theTemplate;        left = (qd.screenBits.bounds.right -             (theRect->right - theRect->left)) / 2;    top = (qd.screenBits.bounds.bottom -             (theRect->bottom - theRect->top)) / 3;    top = Max(top, GetMBarHeight() + 1);    theRect->right += left - theRect->left;    theRect->left = left;    theRect->bottom += top - theRect->top;    theRect->top = top;}/************************************************************ TrapAvailable  Check whether a certain trap exists on this machine. This  function uses the new method as per IM VI, p. 3-8.     ************************************************************/Boolean MyTrapAvailable( short theTrap){    TrapType tType;    short    numToolBoxTraps;        // first determine the trap type                    tType = (theTrap & 0x800) > 0 ? ToolTrap : OSTrap;        // next find out how many traps there are                    if (NGetTrapAddress( _InitGraf, ToolTrap) ==                     NGetTrapAddress( 0xAA6E, ToolTrap))        numToolBoxTraps = 0x200;    else        numToolBoxTraps = 0x400;        // check if the trap number is too big for the    // current trap table                    if (tType == ToolTrap)    {        theTrap &= 0x7FF;        if (theTrap >= numToolBoxTraps)            theTrap = _Unimplemented;    }        // the trap is implemented if its address is    // different from the unimplemented trap                    return (NGetTrapAddress( theTrap, tType) !=             NGetTrapAddress(_Unimplemented, ToolTrap));}/************************************************************ WNEIsImplemented     Check whether the WaitNextEvent is implemented or not ************************************************************/Boolean     WNEIsImplemented(void){    SysEnvRec   theWorld; //System environment        SysEnvirons(1, &theWorld); // Check environment        // Old ROMs, definitely not present    if (theWorld.machineType < 0)                               return(false);    else    // Check for WNE trap        return(MyTrapAvailable(_WaitNextEvent));}/************************************************************ cstrlen  Return the length of a cstring.  It's here so we don't have to drag in ANSI.************************************************************/long cstrlen( register char *s ){    register long count = 0;        while (*s++) count++;    return count;}/************************************************************ CenterRectWithinRect     Center the passed rect within the bounds rect.************************************************************/void    CenterRectWithinRect(const Rect *bounds, Rect *aRect){    short   left,top;        left = (bounds->right -                 (aRect->right - aRect->left)) / 2;    top = (bounds->bottom -                 (aRect->bottom - aRect->top)) / 2;    aRect->right += left - aRect->left;    aRect->left = left;    aRect->bottom += top - aRect->top;    aRect->top = top;}OSErr	MakeGWorld(GWorldPtr * resultGWorld, Rect * localBounds){		Rect		globalBnds;	GDHandle	oldGDevice;	CGrafPtr 	oldCPort;	OSErr		err;	GWorldPtr 	aGWorld;		ASSERT(resultGWorld);	ASSERT(localBounds);	err = noErr;	*resultGWorld = nil; // In case we fail	globalBnds = *localBounds;		// Get the bounds into global coordiantes	LocalToGlobal((Point *)&globalBnds.top);	LocalToGlobal((Point *)&globalBnds.bottom);	// Remember where we are, graphically speaking	GetGWorld(&oldCPort, &oldGDevice);		// Get a gWorld with a depth matching the screens	err = NewGWorld(&aGWorld, 0, &globalBnds, nil, nil, noNewDevice);	if(!err)	{		PixMapHandle pixelsH;				// Succesfully created a GWorld now erase it		SetGWorld(aGWorld, nil);		pixelsH = GetGWorldPixMap(aGWorld);				if (LockPixels(pixelsH))			EraseRect(&aGWorld->portRect);					UnlockPixels(pixelsH);				// don't forget to pass it back		*resultGWorld = aGWorld;	}		// Back to where we started	SetGWorld(oldCPort, oldGDevice);		return err;		}unsigned short PinRandom( unsigned short min, unsigned short max){	unsigned short random;	long range, temp;	random = Random();	range = (max - min) + 1;	temp = (random * range) / 65536;	random = temp + min;	return random;}RgnHandle gOldDesktopRgn = NULL;void HideMenuBar(GrafPtr someGrafPort){	GrafPtr oldPort;	RgnHandle newDesktopRgn;	GetPort(&oldPort);	SetPort(someGrafPort);	gOldDesktopRgn = NewRgn();	CopyRgn(someGrafPort->visRgn, gOldDesktopRgn);	newDesktopRgn = NewRgn();	RectRgn(newDesktopRgn, &someGrafPort->portRect);	CopyRgn(newDesktopRgn, someGrafPort->visRgn);	DisposeRgn(newDesktopRgn);	SetPort(oldPort);}void ShowMenuBar(GrafPtr someGrafPort){	RgnHandle cornersRgn;	GrafPtr oldPort;	GetPort(&oldPort);	SetPort(someGrafPort);	cornersRgn = NewRgn();	CopyRgn(gOldDesktopRgn, cornersRgn);	DiffRgn(someGrafPort->visRgn, cornersRgn, cornersRgn);	FillRgn(cornersRgn, &qd.black);	DisposeRgn(cornersRgn);	CopyRgn(gOldDesktopRgn, someGrafPort->visRgn);	DisposeRgn(gOldDesktopRgn);	gOldDesktopRgn = NULL;	DrawMenuBar();}