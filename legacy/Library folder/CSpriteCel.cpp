/****************************************************************************** CSpriteCel.cp   ******************************************************************************/#include "Assert.h"#include "CSpriteCel.h"#include "ErrorHandler.h"#include "CommonUtilities.h"#include "PrivateUtilities.h"CSpriteCel::CSpriteCel(){	CSpriteCelX();}CSpriteCel::CSpriteCel(short cicnID){		CIconHandle iconH;		CSpriteCelX();		// Load in the Color icon	iconH = GetCIcon(cicnID);		if(iconH)	{		OSErr	err;				HLock((Handle) iconH);				// Create the cel's pixel image		err = MakeCelGWorld(iconH);				// Turn icon's mask into a region		if(!err)			err = MakeRgnMask(iconH);				if(!err)			err = InitCollisionMaskData(iconH);				if(!err)			err = MakeCollisionPixMask(iconH);				fCelBnds = (*iconH)->iconPMap.bounds;		OffsetRect(&fCelBnds, -fCelBnds.left, -fCelBnds.top);				HUnlock((Handle) iconH);		// Before possibly posting error get rid of the icon		DisposeCIcon(iconH);				if(err)			PostFatalError(err);	}		OffsetRect(&fCollisionRect, 					-fCollisionRect.left, 					-fCollisionRect.top);		fHorzCenterOffset = fHorzCollisionMaskOffset + 								fCollisionRect.right / 2;	fVertCenterOffset = fVertCollisionMaskOffset + 								fCollisionRect.bottom / 2;	}			CSpriteCel::~CSpriteCel(){	if(fMaskRgn)		DisposeRgn(fMaskRgn);	fMaskRgn = nil;		if(fCelImage)		DisposeGWorld(fCelImage);	fCelImage = nil;		if(fCollisionMask)		DisposeGWorld(fCollisionMask);	fCollisionMask = nil;		// Disposing of the GWorld killed off the pixels	fCelPixels = nil;	fCollisionMaskPixels = nil;}	void	CSpriteCel::BlitToBuffer(GWorldPtr buffer, const Rect * target){		// Align the mask with the target's upper left corner remembering	// to adjust for the regions offset		OffsetRgn(fMaskRgn,		(target->left - (*fMaskRgn)->rgnBBox.left) + fHorzMaskOffset,		(target->top - (*fMaskRgn)->rgnBBox.top) + fVertMaskOffset);			CopyBits(&((GrafPtr)fCelImage)->portBits,			&((GrafPtr)buffer)->portBits,			&fCelBnds,			target,			srcCopy,			fMaskRgn);			}Boolean	CSpriteCel::Intersect(CSpriteCel * testCel, 								const Rect * testSpriteBnds, 								const Rect * mySpriteBnds){	const Rect		sectBnds;	Rect			myCollisionRect;	Rect			testCollisionRect;	Rect			tempRect;		GetCollisionRect(&myCollisionRect);	testCel->GetCollisionRect(&testCollisionRect);		OffsetRect(&myCollisionRect,			mySpriteBnds->left - myCollisionRect.left + GetCollisionRectOffsetX(),			mySpriteBnds->top - myCollisionRect.top + GetCollisionRectOffsetY());		OffsetRect(&testCollisionRect,			testSpriteBnds->left - testCollisionRect.left + testCel->GetCollisionRectOffsetX(),			testSpriteBnds->top - testCollisionRect.top + testCel->GetCollisionRectOffsetY());			if(SectRect(testSpriteBnds, mySpriteBnds, (Rect *)&sectBnds))		if(SectRect(&testCollisionRect, &myCollisionRect, &tempRect))			return IsLogicalCollision(*fCollisionMaskPixels,									   *(testCel->fCollisionMaskPixels),								       mySpriteBnds, testSpriteBnds, &sectBnds);		else			return false;	else		return false;}OSErr	CSpriteCel::MakeRgnMask(CIconHandle iconH){	BitMap 	maskBits;	OSErr	err;		ASSERT(iconH);	ASSERT(fMaskRgn);		HLock((Handle) iconH);		maskBits = (*iconH)->iconMask;		// Patch up the bitmap's address and bounds		OffsetRect(&maskBits.bounds, 					-maskBits.bounds.left, 					-maskBits.bounds.top);		maskBits.baseAddr = (Ptr) (*iconH)->iconMaskData;		// Make a mask 		err = BitMapToRegion(fMaskRgn, &maskBits);	HUnlock((Handle) iconH);		// Remember the delta from the mask's pixels upper left	// to the regions upper left. We'll need this info to 	// properly reposition the mask relative to cel's blitting	// destination	if(!err)	{		fHorzMaskOffset = (*fMaskRgn)->rgnBBox.left;		fVertMaskOffset = (*fMaskRgn)->rgnBBox.top;	}	return err;}OSErr	CSpriteCel::MakeCelGWorld(CIconHandle iconH){	OSErr	err;	Rect	celBnds;		ASSERT(iconH);		celBnds = (*iconH)->iconPMap.bounds;		// Fix the gworld's coordinates	OffsetRect(&celBnds, -celBnds.left, -celBnds.top);	err = MakeGWorld(&fCelImage, &celBnds);	if(!err)	{		CGrafPtr 		oldPort;		GDHandle		oldDevice;		PixMapHandle	celPixels;				GetGWorld(&oldPort, &oldDevice);		SetGWorld(fCelImage, nil);		celPixels = GetGWorldPixMap(fCelImage);		if(celPixels != nil && LockPixels(celPixels))		{			// Blit the pixels			PlotCIcon(&celBnds, iconH);						// Save the pixel handle.			// Cel's pixel handle will stayed locked until			// it's destruction			fCelPixels = celPixels;		}					SetGWorld(oldPort, oldDevice);	}		return err;}OSErr	CSpriteCel::InitCollisionMaskData(CIconHandle iconH){	RgnHandle	tempRgn = NewRgn();	BitMap 		maskBits;	OSErr		err;		ASSERT(iconH);	ASSERT(tempRgn);		HLock((Handle) iconH);		maskBits = (*iconH)->iconBMap/*iconMask*/;		// Patch up the bitmap's address and bounds		OffsetRect(&maskBits.bounds, 					-maskBits.bounds.left, 					-maskBits.bounds.top);		//maskBits.baseAddr = (Ptr) (*iconH)->iconMaskData;		// Make a mask 		err = BitMapToRegion(tempRgn, &maskBits);	HUnlock((Handle) iconH);		// Remember the delta from the mask's pixels upper left	// to the regions upper left. We'll need this info to 	// properly reposition the mask relative to cel's blitting	// destination	if(!err)	{		fCanCollide = !EmptyRgn(tempRgn);		fHorzCollisionMaskOffset = (*tempRgn)->rgnBBox.left;		fVertCollisionMaskOffset = (*tempRgn)->rgnBBox.top;		fCollisionRect = (*tempRgn)->rgnBBox;	}		if(tempRgn)		DisposeRgn(tempRgn);	return err;}OSErr	CSpriteCel::MakeCollisionPixMask(CIconHandle iconH){	OSErr	err;	Rect	celBnds;		ASSERT(iconH);		celBnds = (*iconH)->iconPMap.bounds;		// Fix the gworld's coordinates	OffsetRect(&celBnds, -celBnds.left, -celBnds.top);	err = MakeGWorld(&fCollisionMask, &celBnds);	if(!err)	{		CGrafPtr 		oldPort;		GDHandle		oldDevice;		PixMapHandle	maskPixels;				GetGWorld(&oldPort, &oldDevice);		SetGWorld(fCollisionMask, nil);		maskPixels = GetGWorldPixMap(fCollisionMask);		if(maskPixels != nil && LockPixels(maskPixels))		{			HLock((Handle)iconH);			// Blit the pixels			CopyBits((const BitMap *)&((*iconH)->iconBMap),					 (const BitMap *)*maskPixels, &celBnds,					 &celBnds, 0, nil);						HUnlock((Handle)iconH);						// Save the pixel handle.			// Cel's pixel handle will stayed locked until			// it's destruction			fCollisionMaskPixels = maskPixels;		}					SetGWorld(oldPort, oldDevice);	}		return err;}void	CSpriteCel::CSpriteCelX(){	fCelImage = nil;	fMaskRgn = NewRgn();		fCelBnds.top = fCelBnds.left = fCelBnds.right = fCelBnds.bottom = 0;	fHorzMaskOffset = 0;	fVertMaskOffset = 0;}