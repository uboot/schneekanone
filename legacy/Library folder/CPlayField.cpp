/****************************************************************************** CPlayField.cp   ******************************************************************************/#include "Assert.h"#include "CPlayField.h"#include "ErrorHandler.h"#include "CObjectList.h"#include "CSchneeSprite.h"#include "CSpriteGroup.h"#include "CommonUtilities.h"CPlayField::CPlayField(CWindowPtr  hostWindow, const Rect* hostBounds){	OSErr err = noErr;		fBkgndBuffer = nil;	fWorkplaceBuffer = nil;	fHostPort = nil;	fSpriteGroups = nil;	fAllSprites = nil;		ASSERT(hostWindow != nil);	fHostPort = hostWindow;	fHostBnds = hostBounds == nil ? hostWindow->portRect : *hostBounds;		// Create the offscreens	err = CreateGWorld(&fBkgndBuffer, &fHostBnds);	if(err)	{		fBkgndBuffer = nil;		PostFatalError(err);		return;	}		err = CreateGWorld(&fWorkplaceBuffer, &fHostBnds);	if(err)	{		fWorkplaceBuffer = nil;		PostFatalError(err);		return;	}	// Create the list that will hold all the sprite groups	fSpriteGroups = new(CObjectList);	if(!fSpriteGroups)		PostFatalError(memFullErr);	// Create the list that will reference all the sprites	fAllSprites = new(CObjectList);	if(!fAllSprites)		PostFatalError(memFullErr);			// List for live sprites to check against still sprites	fLiveSprites = new(CObjectList);	if(!fLiveSprites)		PostFatalError(memFullErr);			fPlayfieldBnds = fHostBnds;	// Force the play field bounds 	// to be 0,0 at the upper-left corner	OffsetRect(&fPlayfieldBnds, -fPlayfieldBnds.left, -fPlayfieldBnds.top);}CPlayField::~CPlayField(){	// Kill off the background buffer	if(fBkgndBuffer)		DisposeGWorld(fBkgndBuffer);	fBkgndBuffer = nil;		// Ditto with the working buffer	if(fWorkplaceBuffer)		DisposeGWorld(fWorkplaceBuffer);	fWorkplaceBuffer = nil;		// Get rid of the master sprite list	if(fAllSprites)		delete(fAllSprites);	fAllSprites = nil;		// Get rid of live list	if(fLiveSprites)		delete(fLiveSprites);	fLiveSprites = nil;		// Get rid of all the sprite groups	if(fSpriteGroups)	{		fSpriteGroups->FreeAll();		delete(fSpriteGroups);	}	fSpriteGroups = nil;}	void	CPlayField::MoveSprites(){	long	i;		// Loop through all the sprite groups	for(i = 1; i <= fAllSprites->GetObjectCount(); i++)	{		CSprite *	currSprite;					currSprite = (CSprite *) fAllSprites->GetNthObject(i);					if(currSprite->IsTimeToMove())		{			currSprite->Move();			SortSprite((CSchneeSprite *)currSprite, i);		}									if(currSprite->IsTimeToChangeCels())			currSprite->ChangeCel();	}			// Loop through all the sprite groups	/*for(long i = 1; i <= fSpriteGroups->GetObjectCount(); i++)	{		CSpriteGroup * currGroup;				currGroup = (CSpriteGroup *)fSpriteGroups->GetNthObject(i);				// Loop through all the sprites in the group		for( long j = 1; j <= currGroup->GetObjectCount(); j++)		{			CSprite *	currSprite;						currSprite = (CSprite *) currGroup->GetNthObject(j);						if(currSprite->IsTimeToMove())			{				currSprite->Move();				//SortSprite((CSchneeSprite *)currSprite, index nicht vergessen!!! );			}										if(currSprite->IsTimeToChangeCels())				currSprite->ChangeCel();					}	} mf79 lšschen*/}void	CPlayField::CheckForCollisions(){		// Loop through all the play fields	for(long i = 1; i <= fSpriteGroups->GetObjectCount(); i++)	{		CSpriteGroup * currGroup;				currGroup = (CSpriteGroup *)fSpriteGroups->GetNthObject(i);		currGroup->CheckForCollisions();	}	}void	CPlayField::ShowNextFrame(){	PixMapHandle	workingPixels;	PixMapHandle	bkgndPixels;		// Lock down the pixels	bkgndPixels = GetGWorldPixMap (fBkgndBuffer);	workingPixels = GetGWorldPixMap(fWorkplaceBuffer);		fLiveSprites->EmptyOutList();		if( LockPixels(bkgndPixels) && LockPixels(workingPixels))	{		// Erase where the sprites have been		EraseSprites();				// Draw the sprite where they are now		BlitSpritesToWorkspace();				// Finally copy the composited areas to the host window		BlitSpritesOnscreen();	}			// Free the pixels	UnlockPixels (bkgndPixels);	UnlockPixels (workingPixels);}void	CPlayField::HandlePlayFieldUpdate(Rect * updateBounds){	PixMapHandle	workingPixels;	PixMapHandle	bkgndPixels;		// Lock down the pixels	bkgndPixels = GetGWorldPixMap (fBkgndBuffer);	workingPixels = GetGWorldPixMap(fWorkplaceBuffer);	SetPort((GrafPtr)fHostPort);		if( LockPixels(bkgndPixels) && LockPixels(workingPixels))	{		CopyBits(&((GrafPtr)fBkgndBuffer)->portBits,				&((GrafPtr)fWorkplaceBuffer)->portBits,				updateBounds,				updateBounds,				srcCopy,				nil);			// Draw the sprite where they are now		UpdateAllSprites();		SetPort((GrafPtr)fHostPort);		CopyBits(&((GrafPtr)fWorkplaceBuffer)->portBits,				&((GrafPtr)fHostPort)->portBits,				updateBounds,				updateBounds,				srcCopy,				nil);						// Free the pixels		UnlockPixels (bkgndPixels);		UnlockPixels (workingPixels);	}		}	void	CPlayField::AddGroup(CSpriteGroup * newGroup){	ASSERT(newGroup);	fSpriteGroups->Add(newGroup);		// Copy the sprite references to the master list	for(long i = 1; i <= newGroup->GetObjectCount(); i++)	{		CSprite *	sprite;				sprite = (CSprite *)newGroup->GetNthObject(i);		fAllSprites->Add(sprite);				SortSprite((CSchneeSprite *)sprite, fAllSprites->GetObjectCount());	}	}void	CPlayField::RemoveGroup(CSpriteGroup * doa_Group){	ASSERT(doa_Group);	fSpriteGroups->Remove(doa_Group);		// Copy the sprite references to the master list	for(long i = 1; i <= doa_Group->GetObjectCount(); i++)	{		CSprite *	sprite;				sprite = (CSprite *)doa_Group->GetNthObject(i);		fAllSprites->Remove(sprite);	}}void	CPlayField::PreDrawOnBackground(){	ASSERT(fBkgndBuffer);		GetGWorld(&fOldCPort, &fOldGDevice);	SetGWorld(fBkgndBuffer, nil);}void	CPlayField::PostDrawOnBackground(){	SetGWorld(fOldCPort, fOldGDevice);}void	CPlayField::PreDrawOnWorkplace(){	ASSERT(fWorkplaceBuffer);		GetGWorld(&fOldCPort, &fOldGDevice);	SetGWorld(fWorkplaceBuffer, nil);}void	CPlayField::PostDrawOnWorkplace(){	SetGWorld(fOldCPort, fOldGDevice);}void	CPlayField::SortSprite(CSchneeSprite * theSprite, long index){	long	i;	long 	distance;		distance = theSprite->GetCurrentDistance();		if(theSprite->CameCloser())		for ( i = index;		     (((CSchneeSprite *)fAllSprites->GetNthObject(i + 1))->		     GetCurrentDistance() > distance) &&		     (i < fAllSprites->GetObjectCount()); i++);		else		for ( i = index;		     (((CSchneeSprite *)fAllSprites->GetNthObject(i - 1))->		     GetCurrentDistance() < distance) && (i > 1); i--);			     		fAllSprites->MoveToAnotherPosition(index, i);}void	CPlayField::EraseSprites(){	// Point at the working buffer	SetGWorld(fWorkplaceBuffer, nil);		// Loop through all the sprite groups	for(long i = 1; i <= fSpriteGroups->GetObjectCount(); i++)	{		CSpriteGroup * currGroup;				currGroup = (CSpriteGroup *)fSpriteGroups->GetNthObject(i);				// Loop through all the sprites in the group		for( long j = 1; j <= currGroup->GetObjectCount(); j++)		{			CSprite *	currSprite;						currSprite = (CSprite *) currGroup->GetNthObject(j);						// Only erase the sprite if it wants to be			if(currSprite->ShouldErase())			{				Rect eraseRect;								// Out of each sprite in the group get the sprite's				// rect that it want erased. The sprite takes care				// of calculating this rectangle as it is moved				currSprite->GetEraseRect(&eraseRect);								// Got the rect, erase it by blitting from the background				// to the working buffer. Override this method to provide				// for different eraseing styles.				EraseChunk(&eraseRect);								// Remember all live sprites				fLiveSprites->Add(currSprite);			}		}	}}void	CPlayField::EraseChunk(Rect * blitRect){#if 0	GrafPtr	oldPort;		GetPort(&oldPort);	SetPort(FrontWindow());		FrameRect(blitRect);	SetPort(oldPort);#endif	CopyBits(	&((GrafPtr)fBkgndBuffer)->portBits,				&((GrafPtr)fWorkplaceBuffer)->portBits,				blitRect,				blitRect,				srcCopy,				nil);}void	CPlayField::UpdateAllSprites(){		// Point at the working buffer	SetGWorld(fWorkplaceBuffer, nil);		// Loop through all the sprites in the group	for( long j = 1; j <= fAllSprites->GetObjectCount(); j++)	{		CSprite *	currSprite;				currSprite = (CSprite *) fAllSprites->GetNthObject(j);				// Only draw the sprite if it wants to be		if(currSprite->IsVisible())		{			currSprite->BlitFrame(fWorkplaceBuffer);		}	}	/*	mf79 lšschen	// Point at the working buffer	SetGWorld(fWorkplaceBuffer, nil);		// Loop through all the sprite groups	for(long i = 1; i <= fSpriteGroups->GetObjectCount(); i++)	{		CSpriteGroup * currGroup;				currGroup = (CSpriteGroup *)fSpriteGroups->GetNthObject(i);				// Loop through all the sprites in the group		for( long j = 1; j <= currGroup->GetObjectCount(); j++)		{			CSprite *	currSprite;						currSprite = (CSprite *) currGroup->GetNthObject(j);						// Only draw the sprite if it wants to be			if(currSprite->IsVisible())			{				currSprite->BlitFrame(fWorkplaceBuffer);			}		}	}*/}void	CPlayField::BlitSpritesToWorkspace(){	// Point at the working buffer	SetGWorld(fWorkplaceBuffer, nil);		// Loop through all the sprite groups	for( long j = 1; j <= fAllSprites->GetObjectCount(); j++)	{		CSprite *	currSprite;					currSprite = (CSprite *) fAllSprites->GetNthObject(j);					// Only draw the sprite if it wants to be		if(currSprite->ShouldDraw())		{			currSprite->BlitFrame(fWorkplaceBuffer);		}		else		{			CorrectForOverlappingStillSprites(currSprite);		}	}		ErasePlayfieldEnds();}void	CPlayField::ErasePlayfieldEnds(){	/* mf79 passende GWorld mu§ vorher aktiviert werden	     bei festgelegten Spielfeldma§en Polygone erstellen (members von CPlayfield) */	}void	CPlayField::CorrectForOverlappingStillSprites(CSprite * stillSprite){	ASSERT(fLiveSprites);		for( long i = 1; i <= fLiveSprites->GetObjectCount(); i++)	{		CSprite *	liveSprite;		Rect		stillBnds, liveBnds, sectBnds;				liveSprite = (CSprite *) fLiveSprites->GetNthObject(i);		liveSprite->GetEraseRect(&liveBnds);		stillSprite->GetPosition(&stillBnds);		if(SectRect(&liveBnds, &stillBnds, &sectBnds) && stillSprite->IsVisible())		{			stillSprite->BlitFrame(fWorkplaceBuffer);			break;		}	}}void	CPlayField::BlitSpritesOnscreen(){	// Point at the host window	SetPort((GrafPtr) fHostPort);		// Loop through all the sprite groups	for(long i = 1; i <= fSpriteGroups->GetObjectCount(); i++)	{		CSpriteGroup * currGroup;				currGroup = (CSpriteGroup *)fSpriteGroups->GetNthObject(i);				// Loop through all the sprites in the group		for( long j = 1; j <= currGroup->GetObjectCount(); j++)		{			CSprite *	currSprite;						currSprite = (CSprite *) currGroup->GetNthObject(j);						// Only copy onscreen if need to			if(currSprite->NeedCopiedOnscreen())			{				Rect copyRect;				Rect eraseRect;				Rect currRect;								// Need to move erased and freshly drawn sprite				// onscreen. The erase & current rects combined				// will return this				currSprite->GetEraseRect(&eraseRect);				currSprite->GetPosition(&currRect);				UnionRect(&eraseRect, &currRect, &copyRect);												// Use low-level onscreen blitter				CopyChunkOnscreen(&copyRect);								currSprite->MarkAsOnscreen();			}		}	}}void CPlayField::CopyChunkOnscreen(Rect * copyBnds){	CopyBits(	&((GrafPtr)fWorkplaceBuffer)->portBits,				&((GrafPtr)fHostPort)->portBits,				copyBnds,				copyBnds,				srcCopy,				nil);				}OSErr	CPlayField::CreateGWorld(GWorldPtr * resultGWorld, Rect * localBounds){		return MakeGWorld(resultGWorld, localBounds);}