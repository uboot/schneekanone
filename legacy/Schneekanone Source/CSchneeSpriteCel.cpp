/****************************************************************************** CSchneeSpriteCel.cp   ******************************************************************************/#include "Assert.h"#include "CSchneeSpriteCel.h"#include "SLVGErrorHandler.h"#include "CommonUtilities.h"#include "PrivateUtilities.h"#define	kCollisionMaskOffset		10000CSchneeSpriteCel::CSchneeSpriteCel(short cicnID) : CSpriteCel(cicnID){		// Load in the Color icon		if(cIconH)	{		OSErr	err;				HLock((Handle) cIconH);				err = InitCollisionMaskData(cIconH);				if(!err)			err = MakeCollisionPixMask(cIconH);				OffsetRect(&fCelBnds, -fCelBnds.left, -fCelBnds.top);				HUnlock((Handle) cIconH);			// Before possibly posting error get rid of the icon		DisposeCIcon(cIconH);		cIconH = nil;				if(err)			PostFatalError(err);	}												   	 	fHorzCenterOffset = fHorzCollisionMaskOffset + 								fCollisionRect.right / 2;	fHorzCenterOffset = fVertCollisionMaskOffset + 								fCollisionRect.bottom / 2;		   	}			CSchneeSpriteCel::~CSchneeSpriteCel(){	if(fCollisionMask)		DisposeGWorld(fCollisionMask);	fCollisionMaskPixels = nil;}Boolean	CSchneeSpriteCel::Intersect(CSchneeSpriteCel * testCel, 								const Rect * testSpriteBnds, 								const Rect * mySpriteBnds){	const Rect		sectBnds;	Rect			myCollisionRect;	Rect			testCollisionRect;	Rect			tempRect;		GetCollisionRect(&myCollisionRect);	testCel->GetCollisionRect(&testCollisionRect);		OffsetRect(&myCollisionRect,			mySpriteBnds->left - myCollisionRect.left + GetCollisionRectOffsetX(),			mySpriteBnds->top - myCollisionRect.top + GetCollisionRectOffsetY());		OffsetRect(&testCollisionRect,			testSpriteBnds->left - testCollisionRect.left + testCel->GetCollisionRectOffsetX(),			testSpriteBnds->top - testCollisionRect.top + testCel->GetCollisionRectOffsetY());			if(SectRect(testSpriteBnds, mySpriteBnds, (Rect *)&sectBnds))		if(SectRect(&testCollisionRect, &myCollisionRect, &tempRect))			return IsLogicalCollision(*fCollisionMaskPixels,									   *(testCel->fCollisionMaskPixels),								       mySpriteBnds, testSpriteBnds, &sectBnds);		else			return false;	else		return false;}OSErr	CSchneeSpriteCel::InitCollisionMaskData(CIconHandle iconH){	RgnHandle	tempRgn = NewRgn();	BitMap 		maskBits;	OSErr		err;		ASSERT(iconH);	ASSERT(tempRgn);		HLock((Handle) iconH);		maskBits = (*iconH)->iconBMap/*iconMask*/;		// Patch up the bitmap's address and bounds		OffsetRect(&maskBits.bounds, 					-maskBits.bounds.left, 					-maskBits.bounds.top);		//maskBits.baseAddr = (Ptr) (*iconH)->iconMaskData;		// Make a mask 		err = BitMapToRegion(tempRgn, &maskBits);	HUnlock((Handle) iconH);		// Remember the delta from the mask's pixels upper left	// to the regions upper left. We'll need this info to 	// properly reposition the mask relative to cel's blitting	// destination	if(!err)	{		fCanCollide = !EmptyRgn(tempRgn);		fHorzCollisionMaskOffset = (*tempRgn)->rgnBBox.left;		fVertCollisionMaskOffset = (*tempRgn)->rgnBBox.top;		fCollisionRect = (*tempRgn)->rgnBBox;	}		if(tempRgn)		DisposeRgn(tempRgn);	return err;}OSErr	CSchneeSpriteCel::MakeCollisionPixMask(CIconHandle iconH){	OSErr	err;	Rect	celBnds;		ASSERT(iconH);		celBnds = (*iconH)->iconPMap.bounds;		// Fix the gworld's coordinates	OffsetRect(&celBnds, -celBnds.left, -celBnds.top);	err = MakeGWorld(&fCollisionMask, &celBnds);	if(!err)	{		CGrafPtr 		oldPort;		GDHandle		oldDevice;		PixMapHandle	maskPixels;				GetGWorld(&oldPort, &oldDevice);		SetGWorld(fCollisionMask, nil);		maskPixels = GetGWorldPixMap(fCollisionMask);		if(maskPixels != nil && LockPixels(maskPixels))		{			HLock((Handle)iconH);			// Blit the pixels			CopyBits((const BitMap *)&((*iconH)->iconBMap),					 (const BitMap *)*maskPixels, &celBnds,					 &celBnds, 0, nil);						HUnlock((Handle)iconH);						// Save the pixel handle.			// Cel's pixel handle will stayed locked until			// it's destruction			fCollisionMaskPixels = maskPixels;		}					SetGWorld(oldPort, oldDevice);	}		return err;}