/****************************************************************************** CEnemy.cp   ******************************************************************************/#include "CommonUtilities.h"#include "CEnemy.h"#include "ErrorHandler.h"#include "CGame.h"#define kLowBorder				160#define kHighBorder				-110extern CGame			gCurrentGame;CSpriteGroup *	CEnemy::cEnemyList = nil;CEnemy::CEnemy(short templateID, CSpriteGroup * enemyGroup)			:CSchneeSprite(templateID){	fEnemyGroup = enemyGroup;		InitEnemy();		fResID = templateID;}CEnemy::CEnemy(CEnemy & source)	:CSchneeSprite(source){	fEnemyGroup = source.fEnemyGroup;		fBaseX = source.fBaseX;	fBaseY = source.fBaseY;		fResID = source.fResID;}CEnemy::~CEnemy(){	// code}void	CEnemy::InitEnemy(){	fBaseX = kNoBase;	fBaseY = kNoBase;		fResID = kNoResID;}void	CEnemy::Move(){	if ((fBaseX != kNoBase) && 		(GetYCenter() < 160 || GetXCenter() >  kLowBorder ||						GetXCenter() < kHighBorder))		if ( IsVisible() )		{			fVisible = false;			CSchneeSprite::Move();		}		else		{			fVisible = true;			SetStartingPosition(fBaseX, fBaseY);		}	else		CSchneeSprite::Move();}void	CEnemy::Hit(){	gCurrentGame.Mistake();}void 	CEnemy::AddEnemyToLevel(MoveObjectRec * object , CSpriteGroup * group){	CEnemy *	enemy = nil;	long		i, j;			for(j = 0; j < object->spriteCount; j++)	{		if(cEnemyList != 0)		{			for(i = 1; i <= cEnemyList->GetObjectCount(); i++)			{				CEnemy *	currEnemy;								currEnemy = (CEnemy *) cEnemyList->GetNthObject(i);								if(currEnemy->fResID == object->spriteID)				{					enemy = (CEnemy *)currEnemy->Clone();					ASSERT(CEnemy);				}			}		}			else				{			cEnemyList = new CSpriteGroup ();				if(cEnemyList == nil)			{				PostFatalError(memFullErr);				return;			}		}				if (enemy == nil)		{			enemy = new CEnemy (object->spriteID, group);										if(enemy == nil)			{				PostFatalError(memFullErr);				return;			}		}			enemy->SetStartingPosition(object->objectPosX + j * object->deltaX,								   object->objectPosY + j * object->deltaY);		enemy->SetAutoMove(object->moveX, object->moveY);		enemy->SetAutoMoveTime(object->moveDelay, object->moveDelayMult);		enemy->SetBasePosition(object->baseX, object->baseY);				cEnemyList->Add(enemy);		group->Add(enemy);	}	}void * CEnemy::Clone(){	CEnemy * clonedEnemy;		clonedEnemy = new CEnemy (*this);	ASSERT(clonedEnemy);	clonedEnemy->InitEnemy();		return clonedEnemy;}void	CEnemy::RemoveEnemy(CEnemy * enemy){	ASSERT(cEnemyList);		enemy->Hide();		enemy->fEnemyGroup->Remove(enemy);	cEnemyList->Remove(enemy);	delete(enemy);}void	CEnemy::ClearOutAllEnemies(){	if(cEnemyList)	{		CEnemy *	enemy;			while((enemy = (CEnemy *)cEnemyList->GetNthObject(1)) != nil)		{			RemoveEnemy(enemy);		}						delete(cEnemyList);		cEnemyList = nil;	}}void	CEnemy::SetBasePosition(short horz, short vert){	fBaseX = horz;	fBaseY = vert;}