/****************************************************************************** CPlayer.cp   ******************************************************************************/#include "CPlayer.h"#include "CPlayField.h"#include "CSpriteGroup.h"#include "CSpriteCel.h"#include "CGame.h"#include "CSoundFX.h"#include "PrivateUtilities.h"#define kPlayerHorzStart		50#define kPlayerVertStart		20#define kPlayerMoveDelay		1#define kPlayerMoveDelayMult	1#define kPlayerGrasDelay		2#define kPlayerGrasDelayMult	1#define kPlayerHorzSpeed		3#define kPlayerVertSpeed		2#define kFinish					955#define kLowBorder				154#define kHighBorder				-103#define kLowFinish				70		#define kHighFinish				-32#define kNumPlayerToStart		1#define kFastStepDistance		2#define kTurnDelay			3// *********** Constants ***********typedef	enum {	left1 = 1,	left2,	left3,	left4,	left5,	left6,	center,	right5,	right4,	right3,	right2,	right1}Direction;typedef	enum {	standard = 1,	eis,	gras}PlayerMode;// *********** Globals ***********extern CPlayField *	gPiste;extern WindowPtr		gMainWindow;extern CSoundFX *		gSchneeSndFX;extern CGame			gCurrentGame;CPlayer::CPlayer(short templateID, CSpriteGroup * playerGroup)	:CSchneeSprite(templateID){	Rect	moveBoundsRect;		ASSERT(playerGroup);		moveBoundsRect = gMainWindow->portRect;		SetSpriteExtent(&moveBoundsRect);		playerGroup->Add(this);		InitPlayer();}void	CPlayer::InitPlayer(){	SetStartingPosition(kPlayerHorzStart, kPlayerVertStart);	SetAutoMoveTime(kPlayerMoveDelay, kPlayerMoveDelayMult);	SetCurrentDirection(center);	SetCurrentCel(center);		fMoveCountdown = kTurnDelay;	fCurrMode = standard;	fModeChange = standard;	fFinished = false;		SetAutoMove(kPlayerHorzSpeed, kPlayerVertSpeed); // von fCurrDirection abhŠngig		Show();}CPlayer::~CPlayer(){	// code}void	CPlayer::SetCurrentDirection(short direction){	fCurrDirection = direction;}void	CPlayer::Move(){	if (MovingLeftKey())	{		if (fCurrDirection > left2)			if (fMoveCountdown == 0)			{				fCurrDirection--;								UpdateMove();								SetCurrentCel(fCurrDirection);							fMoveCountdown = kTurnDelay;			}				else				fMoveCountdown--;	}	else if(MovingRightKey())	{		if (fCurrDirection < right2)			if(fMoveCountdown == 0)			{				fCurrDirection++;								UpdateMove();								SetCurrentCel(fCurrDirection);							fMoveCountdown = kTurnDelay;			}			else				fMoveCountdown--;	}			if(MovingFastKey() && gCurrentGame.CanGoFast())	{		fStepDistance = kFastStepDistance;		gCurrentGame.LoseXLScore(1);	}	else		fStepDistance = kStandardStepDistance;					if(fCurrMode != fModeChange)	{		fCurrMode = fModeChange;		UpdateMove();	}		fModeChange = standard;				CSchneeSprite::Move();		if(GetXCenter() > kLowBorder || GetXCenter() < kHighBorder)		gCurrentGame.Mistake();	else		if(GetYCenter() > kFinish)			if(GetXCenter() > kLowFinish || GetXCenter() < kHighFinish)				gCurrentGame.Mistake();			else				fFinished = true;}void	CPlayer::Collide(CSprite * source){	CSpriteCel *	testCel;	Rect			testSpriteBnds;	Rect			mySpriteBnds;	testCel = source->GetCurrentCel();	source->GetPosition(&testSpriteBnds);	GetPosition(&mySpriteBnds);		if(IsVisible())		if(fCurrentCel->Intersect(testCel, &testSpriteBnds, &mySpriteBnds))			switch(source->GetDogTag())			{				case kGrasTag:					fModeChange = gras;					break;									case kEisTag:					fModeChange = eis;					break;									default:					((CSchneeSprite *)source)->Hit();					break;			}}Boolean	CPlayer::Finished(){	return fFinished;}void		CPlayer::UpdateMove(){	short	tempDirection;		tempDirection = fCurrDirection;		switch(fCurrMode)	{		case eis:			switch(fCurrDirection)			{				case left2:					tempDirection = center - 1;					break;									case right2:					tempDirection = center + 1;					break;								default:					tempDirection = center;					break;			}			break;				case gras:			SetAutoMoveTime(kPlayerGrasDelay, kPlayerGrasDelayMult);			break;				default:			SetAutoMoveTime(kPlayerMoveDelay, kPlayerMoveDelayMult);			break;	}						switch(tempDirection)	{		case left1:			SetAutoMove(-1, 1);		break;				case left2:			SetAutoMove(-2, 3);		break;				case left3:			SetAutoMove(-1, 3);		break;				case left4:			SetAutoMove( 0, 1);		break;				case left5:			SetAutoMove( 1, 3);		break;				case left6:			SetAutoMove( 1, 1);		break;				case center:			SetAutoMove( 3, 2);		break;				case right5:			SetAutoMove( 3, 1);		break;				case right4:			SetAutoMove( 1, 0);		break;				case right3:			SetAutoMove( 3,-1);		break;				case right2:			SetAutoMove( 3,-2);		break;				case right1:			SetAutoMove( 1,-1);		break;	}}Boolean CPlayer::MovingLeftKey(){	return KeyIsDown(kLeftArrowKey);}Boolean CPlayer::MovingRightKey(){	return KeyIsDown(kRightArrowKey);}Boolean CPlayer::MovingFastKey(){	return KeyIsDown(kSpaceBar);}