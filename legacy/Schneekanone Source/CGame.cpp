/****************************************************************************** CGame.cp   ******************************************************************************/#include "CGame.h"#include "CommonUtilities.h"#include "PrivateUtilities.h"#include "CPlayer.h"#include "CEnemy.h"#include "CBonusSprite.h"#include "CScoreTable.h"#include "CPlayField.h"#include "CSpriteGroup.h"#include "CSoundFX.h"#define	kBaseLevelID			1000#define kLevelResType			'Levl'#define kPauseGame				2007#define kSaveFileCreator		'pSKN'#define kSaveFileType			'SkGm'#define kPlayerTemplateID		200#define kTimeLimit				800#define kGameLoopTicks			1extern CSoundFX *			gSchneeSndFX;extern CPlayField *		gPiste;extern WindowPtr       	gMainWindow;extern	StandardFileReply	gLastReply;extern Boolean			gFirstFile;CSpriteGroup *			gPlayerGroup = nil;CSpriteGroup *			gEnemyGroup = nil;CSpriteGroup *			gBonusGroup = nil;CSpriteGroup *			gTableGroup = nil;CPlayer *				gPlayerSprite;void CGame::ResetGame(){		fScoreTable.Reset();		fMistake = false;	fGameRunning = false;	fGameCounter = 0;		InitPlayField();	SetupNextLevel(true);}void CGame::Game(){	if (PlayerDead())		ResetGame();		RunGameLoop();		}void CGame::InitGame(){	BuildPlayFields();		ResetGame();}void CGame::LoadGame(Boolean as){   	StandardFileReply	reply;   	SFTypeList			typeList;   	OSErr				err;   	short				oldFile, fileRef;   	Handle				game;  	if (as)  	{  		typeList[0] = kSaveFileType;		StandardGetFile(nil, 1, typeList, &reply);	}	else    	reply = gLastReply;  	if ( reply.sfGood )   	{    	oldFile = CurResFile ();    	fileRef = FSpOpenResFile(&reply.sfFile, fsRdPerm);    	UseResFile(fileRef);   		game = GetResource('Save', 0);   		   		fScoreTable.Reset();    	fScoreTable.fCurrGameState = **((GameState**)game);    	    	ReleaseResource(game);    	UseResFile(oldFile);    	CloseResFile(fileRef);    	gLastReply = reply;    	    	fGameCounter = kTimeLimit;    	SetupNextLevel(true);    	Game();   }  }void CGame::SaveGame(Boolean as){ 	StandardFileReply	reply;   	SFTypeList			typeList;   	OSErr 				err;   	short				oldFile, fileRef;   	GameStateHnd		game;	if ( ! as && (gLastReply.sfGood) )  		reply = gLastReply;  	else  		if(!gFirstFile)  			StandardPutFile("\pSave the game in what file?", gLastReply.sfFile.name, &reply);  		else  			StandardPutFile("\pSave the game in what file?", "\pUntitled", &reply);  	if ( reply.sfGood )   	{    	oldFile = CurResFile ();/* Delete in case there's an old file */    	err = FSpDelete(&reply.sfFile);    	err = FSpCreate(&reply.sfFile, kSaveFileCreator, kSaveFileType, 0); /*smRoman = 0*/    	FSpCreateResFile(&reply.sfFile, kSaveFileCreator, kSaveFileType, 0); /*smRoman = 0*/    	fileRef = FSpOpenResFile(&reply.sfFile, fsRdWrPerm);   		UseResFile(fileRef);   		   		game = (GameStateHnd)NewHandle(sizeof(GameState));   		**game = fScoreTable.fPrevGameState;    	AddResource((Handle)game, 'Save', 0, "\pGame save information");   		WriteResource((Handle)game);    	DetachResource((Handle)game);    	UseResFile(oldFile);    	CloseResFile(fileRef);    	DisposHandle((Handle)game);    	gLastReply = reply;    	gFirstFile = false;   	}}/************************************************************ BuildPlayFields	Initialize the play field and all permanent sprites 	used in the game   ************************************************************/void	CGame::BuildPlayFields(void){	OSErr			err;		// Create the playfield	gPiste = new CPlayField ((CWindowPtr)gMainWindow, &gMainWindow->portRect);	ASSERT(gDiggerPlayfield);		// Create the sprite groups	gPlayerGroup = new CSpriteGroup;	ASSERT(gPlayerGroup);		gEnemyGroup = new CSpriteGroup;	ASSERT(gEnemyGroup);		gBonusGroup = new CSpriteGroup;	ASSERT(gBonusGroup);		gTableGroup = new CSpriteGroup;	ASSERT(gBonusGroup);		gTableGroup->AddSprite(&fScoreTable);		// Create the player sprite	gPlayerSprite = new CPlayer (kPlayerTemplateID, gPlayerGroup);	ASSERT(gPlayerSprite);		// Created a layer and a sprites	// Add the groups to the playfield	gPiste->AddGroup(gPlayerGroup);	gPiste->AddGroup(gTableGroup);		// Players colide with monsters	gPlayerGroup->AddGroupToCheck(gEnemyGroup);	gPlayerGroup->AddGroupToCheck(gBonusGroup);				RedrawBackground();}/************************************************************ RedrawBackground	Draw the dirt level background to be used by the 	playfield   ************************************************************/void	CGame::RedrawBackground(void){	PicHandle bkgndPictH;		gPiste->PreDrawOnBackground();		// load in the picture for the background	bkgndPictH = GetPicture(128);	if(bkgndPictH)	{		HLock((Handle)bkgndPictH);		DrawPicture(bkgndPictH, &(*bkgndPictH)->picFrame);				HUnlock((Handle)bkgndPictH);		ReleaseResource((Handle)bkgndPictH);	}		// Draw the level we are currently at	/*{		Str255		levelStr;		RGBColor 	color =  {39321,13107,26214};		RGBColor	black = {0,0,0};						RGBForeColor(&color);		TextFont(times);		TextSize(24);		NumToString(gCurrentLevel + 1, levelStr);		MoveTo(337, 47);		DrawString(levelStr);		RGBForeColor(&black);	}*/	gPiste->PostDrawOnBackground();}/************************************************************ RunGameLoop	Main gameloop   ************************************************************/void		CGame::RunGameLoop(void){	long	ticks;			fGameRunning = true;			HideMenuBar(gMainWindow);	//HideCursor();		gPiste->HandlePlayFieldUpdate(&gMainWindow->portRect);		PerformLevelGetReady(2);		while(fGameRunning > 0)	{		if(MadeMistake())			//mf79 eventuell KillOffCurrentPlayer		{			if( ! PlayerDead())			{				SetupNextLevel(false);				PerformLevelGetReady(2);			}		}						if(KeyIsDown(kEscapeKey))		{			gSchneeSndFX->PlaySnd(kPauseGame, kAlarmPriority);			fGameRunning = false;		}				if (PlayerDead())			break;					if(LevelComplete())		{			if(!LastLevel())			{				fScoreTable.fCurrGameState.fLevel++;				InitPlayField();				SetupNextLevel(true);				PerformLevelGetReady(2);			}			else			{				InitPlayField();				ResetGame();				break;			}		}				while ((TickCount() - ticks) < kGameLoopTicks);				ticks = TickCount();								gPiste->MoveSprites();		gPiste->CheckForCollisions();		gPiste->ShowNextFrame();		gSchneeSndFX->SoundFXTask();  // Process sounds				fGameCounter++;			SystemTask();			}		ShowCursor();	ShowMenuBar(gMainWindow);		// If the player runs out of lives, perform a game over celebration	/*if(gPlayerLives == 0)		PerformGameOverCelebration();*/	}/************************************************************ LevelComplete	This level is done when all the monsters have been	vanquished.   ************************************************************/Boolean	CGame::LevelComplete(void){	return gPlayerSprite->Finished();}/************************************************************ InitPlayField	Set the playfield up for another run   ************************************************************/void	CGame::InitPlayField(void){		RedrawBackground();			gPiste->ShowNextFrame();}/************************************************************ SetupNextLevel	Player moved on to the next level. Set it up.************************************************************/void	CGame::SetupNextLevel(Boolean newLevel){	short 				i;	Handle				levelHandle;	FixedObjectList *	unbeweglicheObjekte;	MoveObjectList *	beweglicheObjekte;	BonusObjectList *	bonusObjekte;	char *				levelNamePtr;		gPiste->RemoveGroup(gEnemyGroup);	CEnemy::ClearOutAllEnemies();			// Get the level layout resource	levelHandle = GetResource(kLevelResType, fScoreTable.fCurrGameState.fLevel + kBaseLevelID);	if(!levelHandle)		return;	HLock(levelHandle);		// Setup ptrs to the elements in the layout	unbeweglicheObjekte = (FixedObjectList *)*levelHandle;					  	beweglicheObjekte = (MoveObjectList *)(((char *)unbeweglicheObjekte) + 					    (unbeweglicheObjekte->objectCount * sizeof(FixedObjectRec) +					    sizeof(short)));			bonusObjekte = (BonusObjectList *)(((char *)beweglicheObjekte) + 					      (beweglicheObjekte->objectCount * sizeof(MoveObjectRec) +					      sizeof(short)));					      	levelNamePtr = (((char *)bonusObjekte) + 					      (bonusObjekte->objectCount * sizeof(BonusObjectRec) +					      sizeof(short)));					      	BlockMove(levelNamePtr, fScoreTable.fLevelName, 256 * sizeof(char));						      	for(i = 0; i < unbeweglicheObjekte->objectCount; i++)	{		MoveObjectRec	object;				ConvertToMoveObject				(&object, &(unbeweglicheObjekte->objects[i]));				CEnemy::AddEnemyToLevel(&object, gEnemyGroup );	}			for(i = 0; i < beweglicheObjekte->objectCount; i++)		CEnemy::AddEnemyToLevel(&(beweglicheObjekte->objects[i]), gEnemyGroup);			if (newLevel)	{		CalculateTimeScore();		fGameCounter = 0;					fScoreTable.NextLevel();				gPiste->RemoveGroup(gBonusGroup);				CBonusSprite::ClearOutAllBonusSprites();				for(i = 0; i < bonusObjekte->objectCount; i++)			CBonusSprite::AddBonusSpriteToLevel(&(bonusObjekte->objects[i]),											gBonusGroup);				gPiste->AddGroup(gBonusGroup);	}					BuildFinish();		HUnlock(levelHandle);		ReleaseResource(levelHandle);		gPiste->AddGroup(gEnemyGroup);		// Set up the player to the correct position	gPlayerSprite->InitPlayer();	// Force redraw of play field	gPiste->HandlePlayFieldUpdate(&gMainWindow->portRect);}void	CGame::CalculateTimeScore(){	short	tempTimeScore;			tempTimeScore = kTimeLimit - fGameCounter;			if(tempTimeScore > 0 && fScoreTable.fCurrGameState.fLevel != 0)		AddScore(tempTimeScore);}	/************************************************************ BuildFinish	Build up finish.************************************************************/void	CGame::BuildFinish(){	FixedObjectRec	ziel;	MoveObjectRec	moveObject;		ziel.objectPosX = 529;	ziel.objectPosY = 369;	ziel.spriteID = 209;	ziel.spriteCount = 1;	ziel.deltaX = 0;	ziel.deltaY = 0;	ConvertToMoveObject(&moveObject, &ziel);		CEnemy::AddEnemyToLevel(&moveObject, gEnemyGroup);			ziel.objectPosX = 529;	ziel.objectPosY = 305;	ziel.spriteID = 210;	ziel.spriteCount = 1;	ziel.deltaX = 0;	ziel.deltaY = 0;	ConvertToMoveObject(&moveObject, &ziel);		CEnemy::AddEnemyToLevel(&moveObject, gEnemyGroup);}/************************************************************ LastLevel See if the player has reached the last level in the game   ************************************************************/Boolean	CGame::LastLevel(){	// Get the level layout resource	return GetResource(kLevelResType,	kBaseLevelID + fScoreTable.fCurrGameState.fLevel + 1) == nil;}/************************************************************ PerformLevelGetReady	Wait a while before starting next level   ************************************************************/void	CGame::PerformLevelGetReady(short secondDelay){	long	startTime = TickCount();		gPiste->ShowNextFrame();		while(TickCount() - startTime < (60 * secondDelay))	{		;	}	gPiste->ShowNextFrame();		//gSchneeSndFX->PlaySnd(kStartLevel, kHighPriority);}void CGame::AddScore(short score){	fScoreTable.fCurrGameState.fScore += score;	fScoreTable.TableChanged();}void CGame::AddXLScore(short score){	fScoreTable.fCurrGameState.fXLScore += score;	fScoreTable.TableChanged();}void CGame::LoseXLScore(short score){	fScoreTable.fCurrGameState.fXLScore -= score;	fScoreTable.TableChanged();}void CGame::AddLives(short lives){	fScoreTable.fCurrGameState.fPlayerLives += lives;	fScoreTable.TableChanged();}void CGame::Mistake(){	fScoreTable.fCurrGameState.fPlayerLives--;		fScoreTable.TableChanged();		fMistake = true;}	Boolean CGame::MadeMistake(){	Boolean	tempMistake = fMistake;		fMistake = false;		return tempMistake;}Boolean CGame::PlayerDead(){	return fScoreTable.fCurrGameState.fPlayerLives < 0;}Boolean CGame::CanGoFast(){	return fScoreTable.fCurrGameState.fXLScore > 0;}